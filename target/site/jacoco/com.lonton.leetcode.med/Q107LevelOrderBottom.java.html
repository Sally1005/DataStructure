<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Q107LevelOrderBottom.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data-structure</a> &gt; <a href="index.source.html" class="el_package">com.lonton.leetcode.med</a> &gt; <span class="el_source">Q107LevelOrderBottom.java</span></div><h1>Q107LevelOrderBottom.java</h1><pre class="source lang-java linenums">package com.lonton.leetcode.med;

import com.lonton.leetcode.common.TreeNode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


/**
 * 107. 二叉树的层序遍历 II &lt;p/&gt;
 * 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;p/&gt;
 * 思路：&lt;p/&gt;
 * 与二叉树的层序遍历不同之处仅在于遍历的方向由从上至下改为从下至上。子节点-&gt;根节点&lt;p/&gt;
 * * 利用 list集合 add(int index, E element) 可以减少部分代码 &lt;p/&gt;
 * 法一： list（荐）； 法二：list + Queue &lt;p/&gt;
 *
 * @author 张利红
 */

<span class="fc" id="L21">public class Q107LevelOrderBottom extends TreeNode {</span>
    /**
     * 层序遍历
     *
     * @param root 根节点
     * @return list
     */
    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        // root 为空，返回空数组
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        if (root == null) return new ArrayList&lt;&gt;();</span>
<span class="fc" id="L31">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span>
        // 第一层
<span class="fc" id="L33">        ArrayList&lt;TreeNode&gt; level = new ArrayList&lt;&gt;(Arrays.asList(root));</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">        while (! level.isEmpty()) {</span>
<span class="fc" id="L35">            ArrayList&lt;TreeNode&gt; nextLevel = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L36">            ArrayList&lt;Integer&gt; values = new ArrayList&lt;&gt;();</span>
            // 遍历level
<span class="fc bfc" id="L38" title="All 2 branches covered.">            for (TreeNode node : level) {</span>
                // 非空 根
<span class="fc" id="L40">                values.add((Integer) node.getVal());</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">                if (node.getLeft() != null) {</span>
<span class="fc" id="L42">                    nextLevel.add(node.getLeft());</span>
                }
<span class="fc bfc" id="L44" title="All 2 branches covered.">                if (node.getRight() != null) {</span>
<span class="fc" id="L45">                    nextLevel.add(node.getRight());</span>
                }
<span class="fc" id="L47">            }</span>
<span class="fc" id="L48">            level = nextLevel;</span>
            // add（0，element）,将数据每次插入到最前面
<span class="fc" id="L50">            result.add(0, values);</span>
<span class="fc" id="L51">        }</span>
<span class="fc" id="L52">        return result;</span>
    }
    // 法二：list + Queue
//    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
//            // 大 list
//            List&lt;List&lt;Integer&gt;&gt; bList = new LinkedList&lt;&gt;();
//            if (root == null) {
//                return bList;
//            }
//            // 创建一个队列，并将根结点加入队列
//            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
//            queue.offer(root);
//            // 当队列为空时，结束循环
//            while (!queue.isEmpty()) {
//                // 求队列当前的大小
//                int size = queue.size();
//                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
//                // 每一层的数据个数
//                while (size &gt; 0) {
//                    // 当队列里有元素时，就将该队列的首元素出队列
//                    TreeNode cur = queue.poll();
//                        // 就将cur里的元素放进list里
//                        list.add(cur.getVal());
//                        if (cur.getLeft() != null) {
//                            // 将cur.left入队列
//                            queue.offer(cur.getLeft());
//                        }
//                        if (cur.getRight() != null) {
//                            queue.offer(cur.getRight());
//                        }
//                    // 小 list 中元素自减
//                    size--;
//                }
//                // add（0，element）,将数据每次插入到最前面
//                bList.add(0,list);
//            }
//            return bList;
//        }

}




















</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>