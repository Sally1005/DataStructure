<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Q889ConstructBinaryTreeFromPreorderAndPostorderTraversal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data-structure</a> &gt; <a href="index.source.html" class="el_package">com.lonton.leetcode.med</a> &gt; <span class="el_source">Q889ConstructBinaryTreeFromPreorderAndPostorderTraversal.java</span></div><h1>Q889ConstructBinaryTreeFromPreorderAndPostorderTraversal.java</h1><pre class="source lang-java linenums">package com.lonton.leetcode.med;


import com.lonton.leetcode.common.TreeNode;

import java.util.HashMap;
import java.util.Map;

/**
 * 889. 根据前序和后序遍历构造二叉树&lt;p/&gt;
 * 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。如果存在多个答案，您可以返回其中 任何 一个。&lt;p/&gt;
 * 思路：&lt;p/&gt;
 * 1. 在前序遍历序列中,第一个元素为树的根节点;&lt;p/&gt;
 * 2. 在后序遍历序列中,最后一个元素为树的根节点,所以根据前序和后序遍历无法确定唯一的一棵二叉树;&lt;p/&gt;
 * 3. 默认左子树存在，则在前序遍历中的第二个元素即为左子树的根节点;&lt;p/&gt;
 * 4. 由于后序遍历的顺序为左——&gt;右——&gt;根,即可以确定左子树的范围;&lt;p/&gt;
 * 5. 在前序遍历中，根节点为left,左子树的根节点left+1,左子树的下标范围为[left+1,left+1+左子树节点的个数],
 *    右子树的下标范围为[left+1+左子树节点的个数+1,right]。&lt;p/&gt;
 *
 * @author 张利红
 */
<span class="fc" id="L22">public class Q889ConstructBinaryTreeFromPreorderAndPostorderTraversal {</span>
    // 存储后序遍历节点信息
<span class="fc" id="L24">    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span>
    // 前序遍历数组
    private int[] preorder;

    /**
     * 从前序与后序遍历序列构造二叉树
     *
     * @param postorder 后序遍历数组
     * @param preorder  前序遍历数组
     * @return 二叉树
     */
    public TreeNode buildTree(int[] preorder, int[] postorder) {
        // 初始化全局变量值
<span class="fc" id="L37">        this.preorder = preorder;</span>
<span class="fc bfc" id="L38" title="All 2 branches covered.">        for (int i = 0; i &lt; postorder.length; i++) {</span>
<span class="fc" id="L39">            map.put(postorder[i], i);</span>
        }
        // 前序遍历中设置索引
<span class="fc" id="L42">        return getTreeNode(0, preorder.length - 1, 0);</span>
    }

    /**
     * 构建二叉树
     *
     * @param start     前序遍历开始下标
     * @param end       前序遍历结束下标
     * @param postStart 后序遍历开始下标
     * @return 构建好的二叉树
     */
    private TreeNode getTreeNode(int start, int end, int postStart) {
        // 上一个节点是叶子节点
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (start &gt; end) {</span>
<span class="fc" id="L56">            return null;</span>
        }
        // 整棵树的根节点
<span class="fc" id="L59">        TreeNode root = new TreeNode(preorder[start]);</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (start == end){</span>
<span class="fc" id="L61">            return root;</span>
        }
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (start &lt; end) { // 防止下标越界异常</span>
            // 左子树的根节点下标
<span class="fc" id="L65">            int lRootIndex = preorder[start + 1];</span>
            // 获取左子树的根节点在后序数组中的位置，并求出左子树的节点个数
<span class="fc" id="L67">            int lSize = map.get(lRootIndex) - postStart + 1;</span>
<span class="fc" id="L68">            root.setLeft(getTreeNode(start + 1, start + lSize, postStart));</span>
<span class="fc" id="L69">            root.setRight(getTreeNode(start + lSize + 1, end, postStart + lSize));</span>
        }
<span class="fc" id="L71">        return root;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>